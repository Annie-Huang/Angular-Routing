https://github.com/Annie-Huang/Angular-Routing
https://github.com/DeborahK/Angular-Routing
http://blogs.msmvps.com/deborahk/angular-routing-problem-solver/


All the rounter path for this system:
http://localhost:4200/welcome


2. Introduction
#####################
D:\react\Angular-Routing>npm install


3. Routing Basics
#######################
Importing the Angular Router
- RouterModule.forRoot()
- Declares the router directives
- Manages our route configuration
- Registers the router service
- Used once for the application

@NgModule({
	imports: [
		BrowserModule,
		RouterModule.forRoot([])
	],
	declarations: [
		AppComponent
	],
	bootstrap: [AppComponent]
})
export classAppModule { }

RouterModule.forChild()
- Declares the router directives
- Manages our route configuration
- Does NOT register the router service
- Used in feature modules


This one will cause delay when serving the data.
	InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),

-----

[
	{ path: 'welcome', component: WelcomeComponent },
	{ path: '', redirectTo: 'welcome', pathMatch: 'full'},
	{ path: '**', component: PageNotFoundComponent }
]
to
[
	{ path: 'home', component: WelcomeComponent },
	{ path: 'welcome', redirectTo: 'home', pathMatch: 'full' },
	{ path: '', redirectTo: 'home', pathMatch: 'full'},
	{ path: '**', component: PageNotFoundComponent }
]

A key point to keep in mind is that the order of the routes in this array matters. 
The router uses a first match wins strategy when matching route paths. 
This means that more specific paths should always be before less specific paths, such as the wildcard path. 

But there is one potential gotcha here. Redirects cannot be chained. The router will do one of these redirects, 
but not both, during one navigation. So if the default route is activated, the route is redirected to the welcome route. 

This imeans, you cannot use '' to redirectTo 'welcome' and then welcome redirectTo 'home'. the '' has to redirect to 'home'

Redirects can be local or absolute. Local redirects replace a single URL segment with a different one, such as our examples here. 
An absolute redirect replaces the entire URL.


 Any one outlet can only display one routed component's template at a time.


--------

Change www.mysite.com/APM/welcome (brower) to (server)
from APM/welcome
to APM/index.html
is through Requires Url rewriting. You can google how to do url rewriting in server side.

Using Hash-based Urls
RouterModule.forRoot([...],{ useHash: true })


Basics Checklist: Setting Up
Define the base path	<base href="/">
Import RouterModule
- Use RouterModule.forRoot() for app routes (one time only!)
- Use RouterModule.forChild() for features

Basics Checklist: Configuring Routes
path: Url segment(s) for the route
- No leading slash
- '' for default route; '**' for wildcard route
- Casing matters
component
- Not string name; not enclosed in quotes
- Component must be imported
Order matters!


4. Routing to Features
##############################
Importing the Angular Router without Service module through RouterModule.forChild([])
- Service
- Configuration
- Directives

Actually, behind the scenes, the routerLink directive calls router.navigate with a provided link parameters array 
so everything that we can pass to router.navigate we can assign to the routerLink directive, and vice versa.

Some parts of the current URL, such as secondary route information, is retained when navigating. 
If we don't want this behavior, there is another navigate method we can use, navigateByUrl.


@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule,
    InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),
    RouterModule.forRoot([
      { path: 'welcome', component: WelcomeComponent },
      { path: '', redirectTo: 'welcome', pathMatch: 'full' },
      { path: '**', component: PageNotFoundComponent }
    ]),
    ProductModule,
    UserModule,
    MessageModule
  ],

RouterModule.forRoot is processed after ProductModule | UserModule | MessageModule



@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule,
    InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),
    AppRoutingModule,	<-- Need to put in last.
    ProductModule,
    UserModule,
    MessageModule
  ]
Order:
	welcome
	''
	**
	products
	login
Now that our application routes are in an external module, the route paths are processed in the order they are specified here, 
so the wildcard path matches every path that is not the welcome or empty path, preventing navigation to any other path below it. 
We need to reorder our imports array to ensure that our wildcard route is last in the list of route paths.


Routing to Features Checklist: Configuration
Import RouterModule
- Be sure to use RouterModule.forChild()
Configure the routes
Order matters!

Routing to Features Checklist: Naming Routes
Use a common root path name for related feature routes
- products
- products/:id
- products/:id/edit

Routing to Features Checklist: Activate with Code
Import the Router
Add a dependency on the Router service
- As a constructor parameter
Use the Router service navigate method
Pass in a link parameters array
- First element is the root Url segment
- All other elements are route parameters or additional Url segments
this.router.navigate(['/welcome']);
this.router.navigateByUrl('/welcome');

Routing to Features Checklist: Routing Modules
Separate out routes to their own routing module
Keep route path order in mind

5. Route Parameters
##########################
When you click the link to change the current url from 
http://localhost:4200/products/5/edit
to 
http://localhost:4200/products/0/edit
To maximize performance and minimize changes to the browser's Document Object Model, or DOM, 
the router reuses a component and its template if only the parameters of the route changes.
If I then click on Add Product, only the route parameter changes, so the Product Edit component and its template are reused and 
not reinitialized. This feature of component reuse is important to understand as we reroute parameters.


The router extracts any route parameters from the URL and supplies them to the component through its ActivatedRoute service. 
The ActivatedRoute service is basically a one-stop shop for route information. 
It provides access to the set of URL segments, route parameters, query parameters, route data, and more, as we'll see later in this course.


The ActivatedRoute service has a snapshot that provides the initial state of the route, including the initial value of the route parameters.
We access a route parameter using the paramMap.get method and pass in the route parameter's placeholder name. 

The ActivatedRoute service also provides an observable. 
The observable keeps a watch on the parameters and receives a notification every time the parameters change,


Back button:
In product-detail.component.html:
        <button class="btn btn-outline-secondary mr-3"
                style="width:80px"
                [routerLink]="['/products']">
          <i class="fa fa-chevron-left"></i> Back
        </button>

Cancel button:
In login.component.html:
            <button class="btn btn-outline-secondary"
                    type="button"
                    style="width:80px"
                    [routerLink]="['/welcome']">
              Cancel
            </button>


Logout button:
In app.component.html:
    <li class="nav-item"
        *ngIf="isLoggedIn">
      <a class="nav-link"
         (click)="logOut()">Log Out</a>
    </li>
  logOut(): void {
    this.authService.logout();
    this.router.navigateByUrl('/welcome');	<< this one is because it want to clear any secondary route...
  }


Optional parameters are the ideal choice when conveying arbitrary or complex information during navigation. 
Optional parameters are route-specific and scope to the particular URL segment, 
so there is no risk of key name collisions with other URL segments. 
	[routerLink]="['/products', {name: productName, code: productCode, startDate: availabilityStart, endDate: availabilityEnd}]"
	localhost:4200/products;name=Controller;code=gmg;startDate=March%201%2C%202018;endDate=March%201%2C%202019

If I do filter by in product list page and also click show image, then click into a product and then back again, the filtered information is gone.
To define parameters that work across multiple routes, to the product detail page and back again for example, we use query parameters. 
Just like optional parameters, we use query parameters to pass optional or complex information. 
Unlike optional parameters, they can be retained across routing paths
	localhost:4200/products/5?filterBy=er&showImage=true
	localhost:4200/products?filterBy=er&showImage=true

We can set queryParamsHandling to preserve to preserve the current query parameters, or merge to merge the query parameters with any existing query parameters. 


Route Parameters Checklist: Required Parameters
Pass needed data on a route
Example:
- Detail component requires an id

Route Parameters Checklist: Optional Parameters
Pass optional or complex information to a route
Example:
- Search component passes search criteria to the List component to filter the data

Route Parameters Checklist: Query Parameters
Pass optional or complex information to a route that is optionally retained across routes		<-- You don't need to do this if it's not retained between routes. In which case, use optional parameter.
Example:
- List component passes its current user selections to the Detail component which passes them back 


6. Prefetching Data Using Route Resolvers
####################################################
The data defined in the data property cannot change throughout the lifetime of the application, so we use it for static data such as the page title here.

Without a route resolver the component class gets the data after it's initialized. 
With a route resolver, the resolver service gets the data so the template is not displayed until it has the data it needs. 
This provides a much cleaner visual appearance, and hence a much nicer user experience.

The ActivatedRouteSnapshot contains information about the currently activated route. We used this snapshot earlier to retrieve route and query parameters. 
The RouterStateSnapshot represents the state of the application's router at a moment in time. 
The RouterStateSnapshot is a tree of ActivatedRouteSnapshots.

What do we do if there is an error? We have several options. 
We could return false from the resolver, which would cancel the route, leaving the user on the prior route. 
We could return a null product and continue, hoping the resolved route can handle a null product. Or 
we could navigate to an error page. 
Which mechanism you use for any particular error depends on your application, the error, and your user interface standards. 
But regardless of the technique you use, there is no built-in resolver mechanism for passing error messages out of a route resolver to the prior or activated route. 

If we return false and leave the user on the prior route, we have no way to tell the user why, and the app will just look broken. 
If we return a null product and continue on to the requested route, we have no way to tell the user why the product is null. And again, the app looks broken. Or 
if we navigate to an error page, we don't have any way to pass a message indicating what the error is. 

As always in web development, there are many ways to work around this and provide an error message. 
We could build a service that holds our error information. 
We could pass the error information as an optional parameter on the route. 
We could override the error handler class and build a custom error handler. Or 
we can define our resolved data to include error information. Let's go with this last one as it is a clean way for the resolver to pass error information to any route we choose. 

To associate a route resolver with a route, we add it to the route configuration that we define within an Angular module. 
This ensures that the data for the route is retrieved using the resolver before the routed component is activated. 

Just ensure that each key for our resolve is unique, but they don't have to be unique across resolves

Route Resolvers Checklist: Building
Create an Angular service
Implement the Resolve<> interface
Add a resolve method

Route Resolvers Checklist: Configuring
Configure using resolve
Give each type of data a logical name
Specify a reference to the route resolver

Route Resolvers Checklist: Reading
Read the data from the route
- Snapshot
- Data Observable


7. Child Routes
##########################
Using child routes, we define a route hierarchy to better organize, encapsulate, and navigate through our application. 
Plus, it makes it easier to lazy load routes, improving the startup performance of the application. 

Child Routes
- Tabbed pages
- Master/detail layouts
- Embedded templates
- Feature modules
- Lazy loading

// Absolute path
<a [routerLink]="['/products', product.id, 'edit', 'info']">Info</a>
// Relative path
<a [routerLink]="['info']">Info</a>
Using an absolute path ties the route activation to the current route hierarchy, so if any levels are later added or changed, each of these paths also need to be changed. 
Often a better option is to use a relative path. 


this.product = this.route.snapshot.data['product'];
this.product = this.route.parent.snapshot.data['product'];
Recall that this syntax provides a reference to the product data instance, so our parent route and each child route with the reference will share that instance.

Validating Across Child Routes:
Option 1: Define the form in the parent component?
	Parent: <form><router-outlet></form>
	Child: <input>...</input>
	An Angular form does not recognize input elements defined within a router-outlet, so if you are using template-driven forms, the input elements never appear in the form's model.
Option 2: Define a form in each child component?
	Parent: <router-outlet>
	Child: <form><input>...</input></form>
	Only one form is active at a time, so only its validation is known since validation is form based.
Option 3: Define all of the tab elements in one component?
	Put the form and all of the tab elements into the product edit component template, then hide and show the different tab elements as needed. 
	While this would work, it would be more difficult to build and maintain, especially as more tabs are added.
Option 4: Define a form in each child component, but perform manual validation?
	Parent: <router-outlet>
	Child: <form><input>...</input></form>



All the nevigation links in the this project.
=======================================================================================================================
Product edit page:
	Cancel 		-> products 			(through [routerLink]="['/products']")
	Save 		-> products 			(through router.navigate(['/products']));)
	Delete 		-> products 			(through router.navigate(['/products']));)
	Basic Information -> path: 'products/:id/edit' + path: 'info'	(through [routerLink]="['info']")	<-- Notice there is not / for absolute path
	Search Tags 	  -> path: 'products/:id/edit' + path: 'tags'	(through [routerLink]="['tags'])	<-- Notice there is not / for absolute path

Product detail page:
	Back 		-> products 			(through [routerLink]="['/products']"
							 	 queryParamsHandling="preserve")	<-- Keep the current queryParams in the URL when going to product list page.
	Edit		-> products/:id/edit		(through [routerLink]="['/products', product.id, 'edit']")

Product list page:
	productName	-> products/:id			(through [routerLink]="['/products', product.id]"
							 	 [queryParams]="{filterBy: listFilter, showImage: showImage}")	<-- Add queryParams into the URL to pass product detail page.
	Edit		-> (old) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']")
			-> (new) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']"
							 Then redirectTo: 'info')

Login page:
	Cancel		-> welcome			(through [routerLink]="['/welcome']")
	Log in		-> products			(through router.navigate(['/products']);)

Header:
	Home		-> welcome			(through [routerLink]="['/welcome']")
	Product List	-> products 			(through [routerLink]="['/products']"
						 	also has this.listFilter = this.route.snapshot.queryParamMap.get('filterBy') || '';
    							  	 this.showImage = this.route.snapshot.queryParamMap.get('showImage') === 'true';) 	<-- Take the queryParam in the URL and apply the fitler onto the product list..
	Add Product	-> products/:id/edit		(through [routerLink]="['/products', 0, 'edit']")
	Log in		-> login			(through [routerLink]="['/login']")
	Log out		-> welcome			(through router.navigateByUrl('/welcome');)	<-- Need to use navigateByUrl to clear all secondardy routing.

Landing page:
	localhost:4200	-> ''				(through redirectTo: 'welcome')

Page that is not available
	localhost:4200/s -> '**'			PageNotFoundComponent component.


Alternative syntax from html to ts file:
=======================================================================================================================
<a [routerLink]="['/products', product.id, 'edit', 'info']">Info</a>
=== this.router.navigate(['/products', this.product.id, 'edit', 'info']);	<< absolute path

<a [routerLink]="['info']">Info</a> === this.router.navigate(['info'], { relativeTo: this.route });	<< relative path


All locations for retrieve parameter from url.
=======================================================================================================================
Product detail page:
	ngOnInit	-> products/:id		(through route.snapshot.paramMap.get('id');)

Product edit page:
	ngOnInit	-> (version1) products/:id/edit	(through this.route.paramMap.subscribe(params => {const id = +params.get('id');...}))
			-> (version2) products/:id/edit (thought this.route.data.subscribe(data => {const resolvedData: ProductResolved = data['resolvedData'];...}))	<-- Prefetch data from its own.
			-> (version3) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']"
							 Then redirectTo: 'info'
							 It means it basically go to [routerLink]="['/products', product.id, 'edit', 'info']"
							 Then in product-edit-info.component:
							 this.route.parent.data.subscribe(data => {this.product = data['resolvedData'].product;...}))	<-- Prefetch data from parent's data.


this.route.snapshot.paramMap.get('id');
this.route.snapshot.queryParamMap.get('filterBy')
this.route.snapshot.data['resolvedData'];

this.route.paramMap.subscribe
