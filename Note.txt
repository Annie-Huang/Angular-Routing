https://github.com/Annie-Huang/Angular-Routing
https://github.com/DeborahK/Angular-Routing
http://blogs.msmvps.com/deborahk/angular-routing-problem-solver/


All the rounter path for this system:
http://localhost:4200/welcome


2. Introduction
#####################
D:\react\Angular-Routing>npm install


3. Routing Basics
#######################
Importing the Angular Router
- RouterModule.forRoot()
- Declares the router directives
- Manages our route configuration
- Registers the router service
- Used once for the application

@NgModule({
	imports: [
		BrowserModule,
		RouterModule.forRoot([])
	],
	declarations: [
		AppComponent
	],
	bootstrap: [AppComponent]
})
export classAppModule { }

RouterModule.forChild()
- Declares the router directives
- Manages our route configuration
- Does NOT register the router service
- Used in feature modules


This one will cause delay when serving the data.
	InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),

-----

[
	{ path: 'welcome', component: WelcomeComponent },
	{ path: '', redirectTo: 'welcome', pathMatch: 'full'},
	{ path: '**', component: PageNotFoundComponent }
]
to
[
	{ path: 'home', component: WelcomeComponent },
	{ path: 'welcome', redirectTo: 'home', pathMatch: 'full' },
	{ path: '', redirectTo: 'home', pathMatch: 'full'},
	{ path: '**', component: PageNotFoundComponent }
]

A key point to keep in mind is that the order of the routes in this array matters. 
The router uses a first match wins strategy when matching route paths. 
This means that more specific paths should always be before less specific paths, such as the wildcard path. 

But there is one potential gotcha here. Redirects cannot be chained. The router will do one of these redirects, 
but not both, during one navigation. So if the default route is activated, the route is redirected to the welcome route. 

This imeans, you cannot use '' to redirectTo 'welcome' and then welcome redirectTo 'home'. the '' has to redirect to 'home'

Redirects can be local or absolute. Local redirects replace a single URL segment with a different one, such as our examples here. 
An absolute redirect replaces the entire URL.


 Any one outlet can only display one routed component's template at a time.


--------

Change www.mysite.com/APM/welcome (brower) to (server)
from APM/welcome
to APM/index.html
is through Requires Url rewriting. You can google how to do url rewriting in server side.

Using Hash-based Urls
RouterModule.forRoot([...],{ useHash: true })


Basics Checklist: Setting Up
Define the base path	<base href="/">
Import RouterModule
- Use RouterModule.forRoot() for app routes (one time only!)
- Use RouterModule.forChild() for features

Basics Checklist: Configuring Routes
path: Url segment(s) for the route
- No leading slash
- '' for default route; '**' for wildcard route
- Casing matters
component
- Not string name; not enclosed in quotes
- Component must be imported
Order matters!


4. Routing to Features
##############################
Importing the Angular Router without Service module through RouterModule.forChild([])
- Service
- Configuration
- Directives

Actually, behind the scenes, the routerLink directive calls router.navigate with a provided link parameters array 
so everything that we can pass to router.navigate we can assign to the routerLink directive, and vice versa.

Some parts of the current URL, such as secondary route information, is retained when navigating. 
If we don't want this behavior, there is another navigate method we can use, navigateByUrl.


@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule,
    InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),
    RouterModule.forRoot([
      { path: 'welcome', component: WelcomeComponent },
      { path: '', redirectTo: 'welcome', pathMatch: 'full' },
      { path: '**', component: PageNotFoundComponent }
    ]),
    ProductModule,
    UserModule,
    MessageModule
  ],

RouterModule.forRoot is processed after ProductModule | UserModule | MessageModule



@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule,
    InMemoryWebApiModule.forRoot(ProductData, { delay: 1000 }),
    AppRoutingModule,	<-- Need to put in last.
    ProductModule,
    UserModule,
    MessageModule
  ]
Order:
	welcome
	''
	**
	products
	login
Now that our application routes are in an external module, the route paths are processed in the order they are specified here, 
so the wildcard path matches every path that is not the welcome or empty path, preventing navigation to any other path below it. 
We need to reorder our imports array to ensure that our wildcard route is last in the list of route paths.


Routing to Features Checklist: Configuration
Import RouterModule
- Be sure to use RouterModule.forChild()
Configure the routes
Order matters!

Routing to Features Checklist: Naming Routes
Use a common root path name for related feature routes
- products
- products/:id
- products/:id/edit

Routing to Features Checklist: Activate with Code
Import the Router
Add a dependency on the Router service
- As a constructor parameter
Use the Router service navigate method
Pass in a link parameters array
- First element is the root Url segment
- All other elements are route parameters or additional Url segments
this.router.navigate(['/welcome']);
this.router.navigateByUrl('/welcome');

Routing to Features Checklist: Routing Modules
Separate out routes to their own routing module
Keep route path order in mind

5. Route Parameters
##########################
When you click the link to change the current url from 
http://localhost:4200/products/5/edit
to 
http://localhost:4200/products/0/edit
To maximize performance and minimize changes to the browser's Document Object Model, or DOM, 
the router reuses a component and its template if only the parameters of the route changes.
If I then click on Add Product, only the route parameter changes, so the Product Edit component and its template are reused and 
not reinitialized. This feature of component reuse is important to understand as we reroute parameters.


The router extracts any route parameters from the URL and supplies them to the component through its ActivatedRoute service. 
The ActivatedRoute service is basically a one-stop shop for route information. 
It provides access to the set of URL segments, route parameters, query parameters, route data, and more, as we'll see later in this course.


The ActivatedRoute service has a snapshot that provides the initial state of the route, including the initial value of the route parameters.
We access a route parameter using the paramMap.get method and pass in the route parameter's placeholder name. 

The ActivatedRoute service also provides an observable. 
The observable keeps a watch on the parameters and receives a notification every time the parameters change,


Back button:
In product-detail.component.html:
        <button class="btn btn-outline-secondary mr-3"
                style="width:80px"
                [routerLink]="['/products']">
          <i class="fa fa-chevron-left"></i> Back
        </button>

Cancel button:
In login.component.html:
            <button class="btn btn-outline-secondary"
                    type="button"
                    style="width:80px"
                    [routerLink]="['/welcome']">
              Cancel
            </button>


Logout button:
In app.component.html:
    <li class="nav-item"
        *ngIf="isLoggedIn">
      <a class="nav-link"
         (click)="logOut()">Log Out</a>
    </li>
  logOut(): void {
    this.authService.logout();
    this.router.navigateByUrl('/welcome');	<< this one is because it want to clear any secondary route...
  }


Optional parameters are the ideal choice when conveying arbitrary or complex information during navigation. 
Optional parameters are route-specific and scope to the particular URL segment, 
so there is no risk of key name collisions with other URL segments. 
	[routerLink]="['/products', {name: productName, code: productCode, startDate: availabilityStart, endDate: availabilityEnd}]"
	localhost:4200/products;name=Controller;code=gmg;startDate=March%201%2C%202018;endDate=March%201%2C%202019

If I do filter by in product list page and also click show image, then click into a product and then back again, the filtered information is gone.
To define parameters that work across multiple routes, to the product detail page and back again for example, we use query parameters. 
Just like optional parameters, we use query parameters to pass optional or complex information. 
Unlike optional parameters, they can be retained across routing paths
	localhost:4200/products/5?filterBy=er&showImage=true
	localhost:4200/products?filterBy=er&showImage=true

We can set queryParamsHandling to preserve to preserve the current query parameters, or merge to merge the query parameters with any existing query parameters. 


Route Parameters Checklist: Required Parameters
Pass needed data on a route
Example:
- Detail component requires an id

Route Parameters Checklist: Optional Parameters
Pass optional or complex information to a route
Example:
- Search component passes search criteria to the List component to filter the data

Route Parameters Checklist: Query Parameters
Pass optional or complex information to a route that is optionally retained across routes		<-- You don't need to do this if it's not retained between routes. In which case, use optional parameter.
Example:
- List component passes its current user selections to the Detail component which passes them back 


6. Prefetching Data Using Route Resolvers
####################################################
The data defined in the data property cannot change throughout the lifetime of the application, so we use it for static data such as the page title here.

Without a route resolver the component class gets the data after it's initialized. 
With a route resolver, the resolver service gets the data so the template is not displayed until it has the data it needs. 
This provides a much cleaner visual appearance, and hence a much nicer user experience.

The ActivatedRouteSnapshot contains information about the currently activated route. We used this snapshot earlier to retrieve route and query parameters. 
The RouterStateSnapshot represents the state of the application's router at a moment in time. 
The RouterStateSnapshot is a tree of ActivatedRouteSnapshots.

What do we do if there is an error? We have several options. 
We could return false from the resolver, which would cancel the route, leaving the user on the prior route. 
We could return a null product and continue, hoping the resolved route can handle a null product. Or 
we could navigate to an error page. 
Which mechanism you use for any particular error depends on your application, the error, and your user interface standards. 
But regardless of the technique you use, there is no built-in resolver mechanism for passing error messages out of a route resolver to the prior or activated route. 

If we return false and leave the user on the prior route, we have no way to tell the user why, and the app will just look broken. 
If we return a null product and continue on to the requested route, we have no way to tell the user why the product is null. And again, the app looks broken. Or 
if we navigate to an error page, we don't have any way to pass a message indicating what the error is. 

As always in web development, there are many ways to work around this and provide an error message. 
We could build a service that holds our error information. 
We could pass the error information as an optional parameter on the route. 
We could override the error handler class and build a custom error handler. Or 
we can define our resolved data to include error information. Let's go with this last one as it is a clean way for the resolver to pass error information to any route we choose. 

To associate a route resolver with a route, we add it to the route configuration that we define within an Angular module. 
This ensures that the data for the route is retrieved using the resolver before the routed component is activated. 

Just ensure that each key for our resolve is unique, but they don't have to be unique across resolves

Route Resolvers Checklist: Building
Create an Angular service
Implement the Resolve<> interface
Add a resolve method

Route Resolvers Checklist: Configuring
Configure using resolve
Give each type of data a logical name
Specify a reference to the route resolver

Route Resolvers Checklist: Reading
Read the data from the route
- Snapshot
- Data Observable


7. Child Routes
##########################
Using child routes, we define a route hierarchy to better organize, encapsulate, and navigate through our application. 
Plus, it makes it easier to lazy load routes, improving the startup performance of the application. 

Child Routes
- Tabbed pages
- Master/detail layouts
- Embedded templates
- Feature modules
- Lazy loading

// Absolute path
<a [routerLink]="['/products', product.id, 'edit', 'info']">Info</a>
// Relative path
<a [routerLink]="['info']">Info</a>
Using an absolute path ties the route activation to the current route hierarchy, so if any levels are later added or changed, each of these paths also need to be changed. 
Often a better option is to use a relative path. 


this.product = this.route.snapshot.data['product'];
this.product = this.route.parent.snapshot.data['product'];
Recall that this syntax provides a reference to the product data instance, so our parent route and each child route with the reference will share that instance.

Validating Across Child Routes:
Option 1: Define the form in the parent component?
	Parent: <form><router-outlet></form>
	Child: <input>...</input>
	An Angular form does not recognize input elements defined within a router-outlet, so if you are using template-driven forms, the input elements never appear in the form's model.
Option 2: Define a form in each child component?
	Parent: <router-outlet>
	Child: <form><input>...</input></form>
	Only one form is active at a time, so only its validation is known since validation is form based.
Option 3: Define all of the tab elements in one component?
	Put the form and all of the tab elements into the product edit component template, then hide and show the different tab elements as needed. 
	While this would work, it would be more difficult to build and maintain, especially as more tabs are added.
Option 4: Define a form in each child component, but perform manual validation?
	Parent: <router-outlet>
	Child: <form><input>...</input></form>


Child Routes: Configuring
Add a children array to the parent route
Define the child routes within that array
Child paths extend the parent route
{
  path: 'products/:id/edit',
  component: ProductEditComponent,
  resolve: { product: ProductResolver },
  children: [
    { path: 'info', component: ProductEditInfoComponent },
    { path: 'tags', component: ProductEditTagsComponent }
  ]
}

Child Routes: Placing
Place the child view by defining a 
RouterOutlet directive in the parent component's template
<div class="card-body">
  <div class="wizard">
    <a [routerLink]="['info']">Info</a>
    <a [routerLink]="['tags']">Tags</a>
  </div>
  <router-outlet></router-outlet>
</div>

Child Routes: Activating
Using an absolute path
- Start with a slash
- Define each Url segment
Using a relative path
- No starting slash
- Only the child Url segment
<a [routerLink]="['/products', product.id, 'edit', 'info']">Info</a>
<a [routerLink]="['info']">Info</a>
this.router.navigate(['/products', this.product.id, 'edit', 'info']);
this.router.navigate(['info'], { relativeTo: this.route });

Child Routes: Obtaining Data
Read the data from the route
- Snapshot
this.product = this.route.snapshot.data['product'];
- Data Observable
this.route.data.subscribe(
  data => this.product = data['product'];
);


8. Grouping and Component-less Routes
##########################################################
There is not components for:
http://localhost:4200/products		(productList is the component http://localhost:4200/products got redirect to)
Here, we grouped the product routes under a parent that has no component, and hence, no outlet (<router-outlet>).  
Why should we group routes under a component-less route? 
Grouping helps us better organize our routes, especially as an application gets larger. 
Grouping allows us to share resolvers and other guards. 


Checklist: Grouping
Define routes as children of one parent route
Specify relative paths
But grouping alone is not sufficient!
	As we saw in this module, the router wants to put these child routes into a router-outlet defined in the parent component's template.

Checklist: Component-less Routes
Add a default path that routes to the desired component
Remove the component from the parent route
The child routes are displayed in a higher-level outlet


9. Styling, Animating, and Watching Routes
#####################################################################
https://angular.io/guide/router
The RouterLinkActive directive toggles css classes for active RouterLink bindings based on the current RouterState.

The NgStyle directive lets you set a given DOM elements style properties.
[ngStyle]="{'background-color':'green'}"
[ngStyle]="{'color':getColor(person.country)}"


The NgClass directive allows you to set the CSS class dynamically for a DOM element.
[ngClass]="{'text-success':true}"
[ngClass]="{
    'text-success':person.country === 'UK',
    'text-primary':person.country === 'USA',
    'text-danger':person.country === 'HK'
  }"


Active route links cascade down through each level of the route tree, so parent and child router links can be active at the same time. 
To override this behavior, you can bind to the [routerLinkActiveOptions] input binding with the { exact: true } expression. 
By using { exact: true }, a given RouterLink will only be active if its URL is an exact match to the current URL.


These routing events include 
NavigationStart, which is triggered when navigation begins, 
RoutesRecognized, which is triggered when the router has found a valid path in the configuration that matches the parsed URL, 
NavigationEnd, which is triggered when navigation ends successfully, 
NavigationCancel, triggered when navigation is canceled such as by a routing guard or redirect. We'll talk more about routing guards a little later in this course. And, of course, 
NavigationError, which is triggered when navigation fails. 

Add { enableTracing: true } and check it in chrome developer tool.


Checklist: Styling
Style the active route using the routerLinkActivedirective
For an exact path match use routerLinkActiveOptions
<a [routerLink]="['info']" routerLinkActive="active">
  Basic Information
</a>
<a routerLinkActive="active" [routerLinkActiveOptions]="{exact:true}">
  ...
</a>

Checklist: Animating
Import BrowserAnimationsModule
Define the animation
Register the animation
Trigger the animation on the router outlet

Checklist: Watching Events
Enable tracing to watch routing events in the console
Add enableTracingto the route configuration
imports: [
  RouterModule.forRoot([
    { path: 'welcome', component: WelcomeComponent },
  ...
], { enableTracing: true })
],
...

Checklist: Reacting to Events
Subscribe to the Router's events observable
Check the event type as needed
this.router.events.subscribe((routerEvent: Event) =>{
  if(routerEvent instanceofNavigationStart) {
    ...
  }
});


10. Secondary Routes
###############################
Secondary Routes
Dashboard
Multi-window user interface
Notes or comments
Messages
…

We must give each secondary router-outlet a name, then we use that name to tell the router to place the secondary content in a specific outlet. 
We can define any number of secondary outlets at the same level of the hierarchy, but each must have a unique name. 

Note that if we were only going to show messages here in the secondary outlet, we should use a nested component instead. 
Secondary outlets only make sense if we are going to display multiple routed components within the outlet. 
For example, we could replace the messages with a product summary when editing the product. 

Secondary Routes Checklist: Named RouterOutlet
Add another RouterOutlet within a template
Set its name attribute to a unique name
<div class="container">
  <router-outlet></router-outlet>
  <router-outlet name='popup'></router-outlet>
</div>

Secondary Routes Checklist: Configuring
Add the outlet property
Set it to the name of the associated RouterOutlet
Secondary Routes Checklist: Configuring
RouterModule.forChild([
  {
    path: 'messages',
    component: MessageComponent,
    outlet: 'popup'
  },
])

Secondary Routes Checklist: Activating
Activate a secondary route using an object and setting its outlets property
- Key: Outlet name
- Value: Link parameters array
<a [routerLink]="[{ outlets: { popup: ['messages'] } }]">Messages</a>
this.router.navigate([{ outlets: { popup: ['messages'] } }]);

Secondary Routes Checklist: Clearing
Clear a secondary route using an object and setting its outlets property
- Key: Outlet name
- Value: null
<a [routerLink]="[{ outlets: { popup: null } }]">Messages</a>
this.router.navigate([{ outlets: { popup: null} }]);


11. Route Guards
########################
we require that the user log in before accessing a specific route. 
We may want to warn the user before leaving a route, such as asking whether to save before navigating away from an edit page with unsaved changes. 
We may want to retrieve data before accessing a route. 

The router first executes the canDeactivate guards for the current route to determine whether the user can leave that route. 
If a feature module is loaded asynchronously, as we discuss in the next module, the canLoad route guard is checked before the module is loaded. 
The router then checks the canActivateChild guards and then the canActivate guards. 
After all other route guards are checked, then the resolvers are executed. 

In this example, the method is canActivate. 
For simple cases, this method can return a Boolean value, true to activate the route, and false to cancel the route activation. 
For more complex cases, we could return an observable or a promise from this method. 
If the return value is a promise or an observable, the router will wait for that promise or observable to complete before proceeding with the navigation. 

D:\react\Angular-Routing>ng generate guard user/auth --dry-run
CREATE src/app/user/auth.guard.spec.ts (346 bytes)
CREATE src/app/user/auth.guard.ts (414 bytes)

The canActivateChild guard is called anytime the URL changes and matches the associated child route, even if only the route parameters change.
The key difference between the canActivate guard and the canActivateChild guard is that the canActivate guard will not re-execute if only the child route is changed.

If the user is on the Product List page and clicks the Add Product menu option, only the child route changes. <-- Check product.module.ts
The canActivate guards on the parent route are not executed again, but any canActivateChild guards are. 

Same thing for our tabs. Any canActivate guards on the parent product edit route are not re-executed when changing tabs, but any canActivateChild guards are. 
Building a canActivateChild guard is very similar to building a canActivate guard, so we won't walk through an example here.

Note that the canDeactivate only works when navigating within the Angular application. 
It does not check the guard if the user navigates to an entirely different site or closes the browser. 

D:\react\Angular-Routing>ng generate guard products/product-edit/product-edit --dry-run
CREATE src/app/products/product-edit/product-edit.guard.spec.ts (389 bytes)
CREATE src/app/products/product-edit/product-edit.guard.ts (421 bytes)




All the nevigation links in the this project. (remember to uncomment 'canActivate: [AuthGuard],' in product.module.ts to activate route guard.
=======================================================================================================================
Product edit page:
	Cancel 		-> products 			(through [routerLink]="['/products']")
	Save 		-> products 			(through this.router.navigate(['/products']));)
	Delete 		-> products 			(through this.router.navigate(['/products']));)
	Basic Information -> path: 'products/:id/edit' + path: 'info'	(through [routerLink]="['info']")	<-- Notice there is not / for absolute path
	Search Tags 	  -> path: 'products/:id/edit' + path: 'tags'	(through [routerLink]="['tags'])	<-- Notice there is not / for absolute path

-----------------------------

Product detail page:
	Back 		-> products 			(through [routerLink]="['/products']"
							 	 queryParamsHandling="preserve")	<-- Keep the current queryParams in the URL when going to product list page.
	Edit		-> products/:id/edit		(through [routerLink]="['/products', product.id, 'edit']")

-----------------------------

Product list page:
	productName	-> products/:id			(through [routerLink]="['/products', product.id]"
							 	 [queryParams]="{filterBy: listFilter, showImage: showImage}")	<-- Add queryParams into the URL to pass product detail page.
			-> products/:id	(without login)	this.router.navigate(['/login']);	<-- Do it as part of auth.guard.ts	

	Edit		-> (old) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']")
			-> (new) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']"
							 Then redirectTo: 'info')
			-> (new) products/:id/edit (without login) 	this.router.navigate(['/login']);	<-- Do it as part of auth.guard.ts	

-----------------------------

Message popup:
	X						(through this.router.navigate([{ outlets: { popup: null} }]);

-----------------------------

Login page:
	Cancel		-> welcome			(through [routerLink]="['/welcome']")
	Log in		-> products			(through router.navigate(['/products']);)

-----------------------------

Header:
	Home		-> welcome			(through [routerLink]="['/welcome']")
	Product List	-> products 			(through [routerLink]="['/products']"
						 	also has this.listFilter = this.route.snapshot.queryParamMap.get('filterBy') || '';
    							  	 this.showImage = this.route.snapshot.queryParamMap.get('showImage') === 'true';) 	<-- Take the queryParam in the URL and apply the fitler onto the product list..
			-> products (without login)	this.router.navigate(['/login']);	<-- Do it as part of auth.guard.ts

	Add Product	-> products/:id/edit			(through [routerLink]="['/products', 0, 'edit']")
			-> products/:id/edit (without login)	this.router.navigate(['/login']);	<-- Do it as part of auth.guard.ts

	Log in		-> login			(through [routerLink]="['/login']")
	Log out		-> welcome			(through router.navigateByUrl('/welcome');)	<-- Need to use navigateByUrl to clear all secondardy routing.

	Show Messages	-> (old) messages (with outlet: 'popup')	(through [routerLink]="[{ outlets: { popup: ['messages'] } }]"
			-> (new) messages (with outlet: 'popup')	(through this.router.navigate([{ outlets: { popup: ['messages'] } }]);	<-- Exactly the same as old one except, we want to add extra logic in the method to change display between 'show' and 'hide'.
	Hide Messages	->						(through this.router.navigate([{ outlets: { popup: null} }]);

-----------------------------

Landing page:
	localhost:4200	-> ''				(through redirectTo: 'welcome')

-----------------------------

Page that is not available
	localhost:4200/s -> '**'			PageNotFoundComponent component.

-----------------------------





Alternative syntax from html to ts file:
=======================================================================================================================
<a [routerLink]="['/products', product.id, 'edit', 'info']">Info</a>
=== this.router.navigate(['/products', this.product.id, 'edit', 'info']);	<< absolute path

<a [routerLink]="['info']">Info</a> 
=== this.router.navigate(['info'], { relativeTo: this.route });	<< relative path






All locations for retrieve parameter from url.
=======================================================================================================================
Product detail page:
	ngOnInit	-> products/:id		(through route.snapshot.paramMap.get('id');)

Product edit page:
	ngOnInit	-> (version1) products/:id/edit	(through this.route.paramMap.subscribe(params => {const id = +params.get('id');...}))
			-> (version2) products/:id/edit (thought this.route.data.subscribe(data => {const resolvedData: ProductResolved = data['resolvedData'];...}))	<-- Prefetch data from its own.
			-> (version3) products/:id/edit	(through [routerLink]="['/products', product.id, 'edit']"
							 Then redirectTo: 'info'
							 It means it basically go to [routerLink]="['/products', product.id, 'edit', 'info']"
							 Then in product-edit-info.component:
							 this.route.parent.data.subscribe(data => {this.product = data['resolvedData'].product;...}))	<-- Prefetch data from parent's data.


this.route.snapshot.paramMap.get('id');
this.route.snapshot.queryParamMap.get('filterBy')
this.route.snapshot.data['resolvedData'];

this.route.paramMap.subscribe
